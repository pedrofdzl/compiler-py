"""
Parser module for the compiler.

This module is responsible for parsing the stream of tokens generated by the
lexer. The parser is implemented as a recursive descent parser.
"""

import ply.yacc as yacc

# Import the list of token names from the lexer
from x_lexer import tokens

# Import the symbol table and exceptions
from symbols import Symbol, SymbolTable

# Global variable to store the symbol table
function_directory = None
# Scope stack
scope_stack = []
# Current id memory for declarations
id_stack = []

def p_prog(p):
    """PROG : PROG_N1 PROG_N2 SEMICOLON PROG_1 MAIN BODY END"""
    print('EoF:', function_directory.lookup(scope_stack.pop()).value)

def p_prog_n1(p):
    """PROG_N1 : PROGRAM"""
    global function_directory
    function_directory = SymbolTable()

def p_prog_n2(p):
    """PROG_N2 : ID"""
    print('create variable table for', p[1])
    function_directory.declare(Symbol(p[1], 'vars', SymbolTable()))
    scope_stack.append(p[1])

def p_prog_1(p):
    """PROG_1 : VARS PROG_2 
            | empty
    """

def p_prog_2(p):
    """PROG_2 : FUNCS PROG_2
            | empty
    """

def p_vars(p):
    """VARS : VARS_N1 VARS_1"""

def p_vars_n1(p):
    """VARS_N1 : VAR"""
    if not function_directory.lookup(scope_stack[-1]).value:
        print('populate value for', scope_stack[-1])
        scope_vars = function_directory.lookup(scope_stack[-1])
        scope_vars.value = SymbolTable()
        function_directory.update(scope_vars)

def p_vars_1(p):
    """VARS_1 : VARS_N2 VARS_2"""
    
def p_vars_n2(p):
    """VARS_N2 : ID"""
    id_stack.append(p[1])

def p_vars_2(p):
    """VARS_2 : TWO_DOTS VARS_N3 SEMICOLON VARS_3
            | COMMA VARS_1
    """

def p_vars_n3(p):
    """VARS_N3 : TYPE"""
    for id in id_stack:
        print('declare', id, 'as', p[1])
        scope_vars = function_directory.lookup(scope_stack[-1])
        scope_vars.value.declare(Symbol(id, p[1]))
        function_directory.update(scope_vars)
    id_stack.clear()

def p_vars_3(p):
    """VARS_3 : VARS_1
            | empty
    """

def p_funcs(p):
    """FUNCS : VOID FUNCS_N1 BRACKET_OPEN FUNCS_1 BRACKET_CLOSE SQ_BRACKET_OPEN FUNCS_4 BODY SQ_BRACKET_CLOSE FUNCS_N3"""

def p_funcs_n1(p):
    """FUNCS_N1 : ID"""
    print('create function', p[1])
    function_directory.declare(Symbol(p[1], 'vars', SymbolTable()))
    scope_stack.append(p[1])   

def p_funcs_1(p):
    """FUNCS_1 : FUNCS_2
            | empty
    """

def p_funcs_2(p):
    """FUNCS_2 : FUNCS_N2 FUNCS_3
            | empty
    """

def p_funcs_n2(p):
    """FUNCS_N2 : ID TWO_DOTS TYPE"""
    print('declare param', p[1], 'as', p[3])
    scope_vars = function_directory.lookup(scope_stack[-1])
    scope_vars.value.declare(Symbol(p[1], p[3]))
    function_directory.update(scope_vars)

def p_funcs_3(p):
    """FUNCS_3 : COMMA FUNCS_2
            | empty
    """

def p_funcs_n3(p):
    """FUNCS_N3 : SEMICOLON"""
    scope_to_pop = scope_stack.pop()
    print('EoFunc:', function_directory.lookup(scope_to_pop).value)
    function_directory.remove(scope_to_pop)

def p_funcs_4(p):
    """FUNCS_4 : VARS
            | empty
    """

def p_type(p):
    """TYPE : INT
            | FLOAT
    """
    p[0] = p[1]

def p_body(p):
    """BODY : CURLY_BRACKET_OPEN BODY_1"""

def p_body_1(p):
    """BODY_1 : STATEMENT BODY_1
            | CURLY_BRACKET_CLOSE
    """

def p_statement(p):
    """STATEMENT : ASSIGNMENT
                | CONDITION
                | CYCLE
                | F_CALL
                | PRINTS
    """

def p_assignment(p):
    """ASSIGNMENT : ID ASSIGN EXPRESSION SEMICOLON"""

def p_condition(p):
    """CONDITION : IF BRACKET_OPEN EXPRESSION BRACKET_CLOSE BODY CONDITION_1"""

def p_condition_1(p):
    """CONDITION_1 : ELSE BODY SEMICOLON
                | SEMICOLON
    """

def p_cycle(p):
    """CYCLE : WHILE BODY DO BRACKET_OPEN EXPRESSION BRACKET_CLOSE SEMICOLON"""

def p_f_call(p):
    """F_CALL : ID BRACKET_OPEN F_CALL_1"""

def p_f_call_1(p):
    """F_CALL_1 : EXPRESSION F_CALL_2"""

def p_f_call_2(p):
    """F_CALL_2 : COMMA F_CALL_1
                | BRACKET_CLOSE SEMICOLON
    """

def p_prints(p):
    """PRINTS : PRINT BRACKET_OPEN PRINTS_1"""

def p_prints_1(p):
    """PRINTS_1 : EXPRESSION PRINTS_2
            | STRING_CONST PRINTS_2
    """

def p_prints_2(p):
    """PRINTS_2 : COMMA PRINTS_1
            | BRACKET_CLOSE SEMICOLON
    """

def p_expression(p):
    """EXPRESSION : EXP EXPRESSION_1"""

def p_expression_1(p):
    """EXPRESSION_1 : LESS_THAN EXPRESSION
                    | MORE_THAN EXPRESSION
                    | LESS_THAN_EQUAL EXPRESSION
                    | MORE_THAN_EQUAL EXPRESSION
                    | EQUAL EXPRESSION
                    | NOT_EQUAL EXPRESSION
                    | empty
    """

def p_exp(p):
    """EXP : TERM EXP_1"""

def p_exp_1(p):
    """EXP_1 : ADD EXP
            | SUBTRACT EXP
            | empty
    """

def p_term(p):
    """TERM : FACTOR TERM_1"""

def p_term_1(p):
    """TERM_1 : MULTIPLY TERM
            | DIVIDE TERM
            | empty
    """

def p_factor(p):
    """FACTOR : BRACKET_OPEN EXPRESSION BRACKET_CLOSE
            | ADD FACTOR_1
            | SUBTRACT FACTOR_1
            | FACTOR_1
    """

def p_factor_1(p):
    """FACTOR_1 : CONSTANT
                | ID
    """

def p_constant(p):
    """CONSTANT : INT_CONST
                | FLOAT_CONST
    """

def p_empty(p):
    """empty :"""
    pass

def p_error(p):
    print(f"Syntax error at line {p.lineno}, position {p.lexpos}, token {p.type}")

# Build the parser
parser = yacc.yacc(debug=True)