"""
Parser module for the compiler.

This module is responsible for parsing the stream of tokens generated by the
lexer. The parser is implemented as a recursive descent parser.
"""

import ply.yacc as yacc

# Import the list of token names from the lexer
from lexer import tokens

def p_prog(p):
    """PROG : PROGRAM ID SEMICOLON PROG_1 MAIN BODY END"""

def p_prog_1(p):
    """PROG_1 : VARS PROG_2 
            | empty
    """

def p_prog_2(p):
    """PROG_2 : FUNCS PROG_2
            | empty
    """

def p_vars(p):
    """VARS : VAR VARS_1"""

def p_vars_1(p):
    """VARS_1 : ID VARS_2"""

def p_vars_2(p):
    """VARS_2 : TWO_DOTS TYPE SEMICOLON VARS_3
            | COMMA VARS_1
            | empty
    """

def p_vars_3(p):
    """VARS_3 : VARS_1
            | empty
    """

def p_funcs(p):
    """FUNCS : VOID ID BRACKET_OPEN FUNCS_2 BRACKET_CLOSE SQ_BRACKET_OPEN FUNCS_3 BODY SQ_BRACKET_CLOSE SEMICOLON"""

def p_funcs_1(p):
    """FUNCS_1 : ID TWO_DOTS TYPE FUNCS_2"""

def p_funcs_2(p):
    """FUNCS_2 : COMMA FUNCS_1
            | empty
    """

def p_funcs_3(p):
    """FUNCS_3 : VARS
            | empty
    """

def p_type(p):
    """TYPE : INT
            | FLOAT
    """

def p_body(p):
    """BODY : CURLY_BRACKET_OPEN BODY_1"""

def p_body_1(p):
    """BODY_1 : STATEMENT BODY_1
            | CURLY_BRACKET_CLOSE
    """

def p_statement(p):
    """STATEMENT : ASSIGNMENT
                | CONDITION
                | CYCLE
                | F_CALL
                | PRINTS
    """

def p_assignment(p):
    """ASSIGNMENT : ID ASSIGN EXPRESSION SEMICOLON"""

def p_condition(p):
    """CONDITION : IF BRACKET_OPEN EXPRESSION BRACKET_CLOSE BODY CONDITION_1"""

def p_condition_1(p):
    """CONDITION_1 : ELSE BODY SEMICOLON
                | SEMICOLON
    """

def p_cycle(p):
    """CYCLE : WHILE BODY DO BRACKET_OPEN EXPRESSION BRACKET_CLOSE SEMICOLON"""

def p_f_call(p):
    """F_CALL : ID BRACKET_OPEN F_CALL_1"""

def p_f_call_1(p):
    """F_CALL_1 : EXPRESSION F_CALL_2"""

def p_f_call_2(p):
    """F_CALL_2 : COMMA F_CALL_1
                | BRACKET_CLOSE SEMICOLON
    """

def p_prints(p):
    """PRINTS : PRINT BRACKET_OPEN PRINTS_1"""

def p_prints_1(p):
    """PRINTS_1 : EXPRESSION PRINTS_2
            | STRING_CONST PRINTS_2
    """

def p_prints_2(p):
    """PRINTS_2 : COMMA PRINTS_1
            | BRACKET_CLOSE SEMICOLON
    """

def p_expression(p):
    """EXPRESSION : EXP EXPRESSION_1"""

def p_expression_1(p):
    """EXPRESSION_1 : LESS_THAN EXPRESSION
                    | MORE_THAN EXPRESSION
                    | LESS_THAN_EQUAL EXPRESSION
                    | MORE_THAN_EQUAL EXPRESSION
                    | EQUAL EXPRESSION
                    | NOT_EQUAL EXPRESSION
                    | empty
    """

def p_exp(p):
    """EXP : TERM EXP_1"""

def p_exp_1(p):
    """EXP_1 : ADD EXP
            | SUBTRACT EXP
            | empty
    """

def p_term(p):
    """TERM : FACTOR TERM_1"""

def p_term_1(p):
    """TERM_1 : MULTIPLY TERM
            | DIVIDE TERM
            | empty
    """

def p_factor(p):
    """FACTOR : BRACKET_OPEN EXPRESSION BRACKET_CLOSE
            | ADD FACTOR_1
            | SUBTRACT FACTOR_1
            | FACTOR_1
    """

def p_factor_1(p):
    """FACTOR_1 : CONSTANT
                | ID
    """

def p_constant(p):
    """CONSTANT : INT_CONST
                | FLOAT_CONST
    """

def p_empty(p):
    """empty :"""
    pass

def p_error(p):
    print(f"Syntax error at line {p.lineno}, position {p.lexpos}, token {p.type}")

# Build the parser
parser = yacc.yacc(debug=True)